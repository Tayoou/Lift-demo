<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Preview Sandbox</title>

  <script src="lib/tailwindcss.js"></script>
  <script>
    tailwind.config = { theme: { extend: { colors: { clifford: "#da373d" } } } };
  </script>

  <script src="lib/react.development.js"></script>
  <script src="lib/react-dom.development.js"></script>
  <script src="lib/babel.min.js"></script>
  <script src="html-to-image.js"></script>

  <style>
    body {
      margin: 0;
      padding: 40px;
      min-height: 100vh;
      background-color: #f8fafc;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      transition: background 0.2s;
      box-sizing: border-box;
    }

    #root {
      box-sizing: content-box;
      padding: 24px;
      width: 100%;
      position: relative;
      transition: all 0.3s;
      /* üî• ËÆ©ÁªÑ‰ª∂Âú®Á∫¶ÊùüÊ°ÜÂÜÖÂ±Ö‰∏≠ */
      margin: 0 auto;
    }

    /* Edit Mode */
    .edit-mode-active .editable-text {
      outline: 2px dashed #3b82f6 !important;
      cursor: text !important;
    }

    .edit-mode-active .editable-text:hover {
      background: rgba(59, 130, 246, 0.1);
    }

    .edit-mode-active a {
      cursor: text !important;
      pointer-events: none;
    }

    /* Loading Overlay */
    #loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(4px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      flex-direction: column;
      gap: 12px;
    }

    #loading-overlay.active {
      display: flex;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e2e8f0;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .loading-text {
      color: #64748b;
      font-size: 12px;
      font-weight: 500;
      font-family: sans-serif;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .error-box {
      padding: 1rem;
      background-color: #fee2e2;
      color: #b91c1c;
      border: 1px solid #f87171;
      border-radius: 0.5rem;
      margin: 1rem;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>

<body>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">AI is coding...</div>
  </div>

  <div id="root"></div>

  <script>
    const rootElement = document.getElementById("root");
    let reactRoot = null;
    let isEditMode = false;

    window.addEventListener("message", (event) => {
      const { type, code, layout, key, value, color, enable } = event.data;

      if (type === "SHOW_LOADING") document.getElementById("loading-overlay").classList.add("active");

      if (type === "RENDER") {
        document.getElementById("loading-overlay").classList.remove("active");
        applyLayout(layout);
        renderCode(code);
      }

      if (type === "UPDATE_STYLE") {
        if (key === "fontFamily") loadGoogleFont(value);
        document.getElementById("root").style.setProperty(key, value);
      }

      if (type === "UPDATE_CANVAS_BG") document.body.style.backgroundColor = color;
      if (type === "TOGGLE_EDIT_MODE") toggleEditMode(enable);
      if (type === "GET_SCREENSHOT") captureScreenshot();
    });

    function renderCode(rawCode) {
      try {
        let code = rawCode.replace(/import\s+.*?from\s+['"].*?['"];?/g, "").replace(/export\s+default\s+/g, "");
        if (code.trim().startsWith("<")) code = `const Component = () => (\n${code}\n);`;

        const codeToRun = `
          ${code}
          let Target = null;
          try { if (typeof Component !== 'undefined') Target = Component; } catch(e){}
          try { if (typeof App !== 'undefined') Target = App; } catch(e){}
          Target;
        `;

        const compiled = Babel.transform(codeToRun, { presets: ["react"] }).code;
        const Component = eval(compiled);

        if (!reactRoot) reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(React.createElement(Component));
      } catch (err) {
        console.error(err);
        document.getElementById("loading-overlay").classList.remove("active");
        rootElement.innerHTML = `<div class="error-box">Render Error: ${err.message}</div>`;
      }
    }

    // üî• Ê†∏ÂøÉ‰øÆÂ§ç: Â∏ÉÂ±ÄÁ∫¶Êùü
    function applyLayout(layout) {
      if (layout && layout.width && layout.width !== "auto") {
        rootElement.style.width = `${layout.width}px`;
        // üî• ‰ΩøÁî® border ËÄå‰∏çÊòØ outlineÔºåÊõ¥Âä†Á®≥ÂÆö
        rootElement.style.border = "2px dashed #cbd5e1";
        rootElement.style.borderRadius = "8px";
      } else {
        rootElement.style.width = "100%";
        rootElement.style.border = "none";
      }
      // ÊúÄÂ∞èÈ´òÂ∫¶‰πüÈúÄË¶ÅË¢´Â∞äÈáçÔºåÈò≤Ê≠¢ÁªÑ‰ª∂Â°åÈô∑
      if (layout && layout.height && layout.height !== "auto") {
        rootElement.style.minHeight = `${layout.height}px`;
      }
    }

    function loadGoogleFont(fontName) {
      if (!fontName) return;
      const cleanName = fontName.split(',')[0].replace(/['"]/g, '').trim();
      if (["serif", "sans-serif", "monospace", "cursive"].includes(cleanName.toLowerCase())) return;
      const id = `font-${cleanName.replace(/\s+/g, '-')}`;
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id; link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${cleanName.replace(/\s+/g, '+')}:wght@400;500;700&display=swap`;
      document.head.appendChild(link);
    }

    function captureScreenshot() {
      const placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      htmlToImage.toPng(document.getElementById('root'), {
        backgroundColor: getComputedStyle(document.body).backgroundColor,
        skipOnError: true,
        cacheBust: true,
        imagePlaceholder: placeholder,
        fetchRequestInit: { mode: 'no-cors' },
        style: { margin: 0 }
      })
        .then(dataUrl => window.top.postMessage({ type: "SCREENSHOT_RESULT", dataUrl }, "*"))
        .catch(err => {
          console.warn("Capture failed:", err);
          window.top.postMessage({ type: "SCREENSHOT_RESULT", dataUrl: null }, "*");
        });
    }

    function toggleEditMode(enable) {
      isEditMode = enable;
      document.body.classList.toggle("edit-mode-active", enable);
      const root = document.getElementById("root");
      if (enable) wrapTextNodes(root);
      else unwrapTextNodes(root);
    }

    function wrapTextNodes(el) {
      Array.from(el.childNodes).forEach(node => {
        if (node.nodeType === 3 && node.nodeValue.trim().length > 0) {
          const span = document.createElement('span');
          span.contentEditable = "true"; span.className = "editable-text";
          span.onclick = e => { e.preventDefault(); e.stopPropagation(); };
          span.setAttribute("data-original-text", node.nodeValue);
          node.parentNode.insertBefore(span, node);
          span.appendChild(node);
        } else if (node.nodeType === 1 && !node.classList.contains('editable-text')) {
          wrapTextNodes(node);
        }
      });
    }

    function unwrapTextNodes(root) {
      root.querySelectorAll('.editable-text').forEach(span => {
        while (span.firstChild) span.parentNode.insertBefore(span.firstChild, span);
        span.parentNode.removeChild(span);
      });
      root.normalize();
    }

    document.addEventListener("focusout", (e) => {
      if (!isEditMode) return;
      if (e.target.classList.contains("editable-text")) {
        const oldText = e.target.getAttribute("data-original-text");
        const newText = e.target.innerText;
        if (oldText && newText !== oldText) {
          e.target.setAttribute("data-original-text", newText);
          window.top.postMessage({ type: "UPDATE_TEXT_CONTENT", oldText, newText }, "*");
        }
      }
    });
  </script>
</body>

</html>