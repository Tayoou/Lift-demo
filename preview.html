<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Preview Sandbox</title>

  <script src="lib/tailwindcss.js"></script>
  <script>
    tailwind.config = { theme: { extend: { colors: { clifford: "#da373d" } } } };
  </script>

  <script src="lib/react.development.js"></script>
  <script src="lib/react-dom.development.js"></script>
  <script src="lib/babel.min.js"></script>
  <script src="html-to-image.js"></script>

  <style>
    /* å…¨å±€å¸ƒå±€ï¼šè®©ç”»å¸ƒå±…ä¸­ */
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    body {
      padding: 40px;
      /* ç»™æ‹–æ‹½ç•™å‡ºç©ºé—´ */
      background-color: #f8fafc;
      /* ğŸ”¥ å…³é”®å¸ƒå±€ï¼šå…è®¸å†…å®¹æ’‘å¼€å®¹å™¨ï¼Œå®ç°æ¨ªå‘æ»šåŠ¨ */
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      overflow: auto;
      box-sizing: border-box;
    }

    /* æ ¸å¿ƒå®¹å™¨ */
    #root {
      box-sizing: content-box;
      /* åˆå§‹é»˜è®¤å€¼ï¼Œä¼šè¢« JS è¦†ç›– */
      min-width: 20px;

      /* ğŸ”¥ æ ¸å¿ƒï¼šé«˜åº¦å®Œå…¨ç”±å†…å®¹å†³å®šï¼Œä¸å¯æ‰‹åŠ¨è°ƒæ•´ */
      height: auto !important;
      min-height: auto !important;

      /* ğŸ”¥ æ ¸å¿ƒï¼šè‡ªåŠ¨å±…ä¸­é­”æ³• (åœ¨ Flex å®¹å™¨ä¸­) */
      margin: auto;
      /* ğŸ”¥ æ ¸å¿ƒï¼šé˜²æ­¢çˆ¶çº§æŒ¤å‹ */
      flex-shrink: 0;

      position: relative;
      border: 2px dashed #cbd5e1;
      border-radius: 8px;
      user-select: none;
      transition: none;
    }

    /* Edit Mode */
    .edit-mode-active .editable-text {
      outline: 2px dashed #3b82f6 !important;
      cursor: text !important;
    }

    .edit-mode-active .editable-text:hover {
      background: rgba(59, 130, 246, 0.1);
    }

    .edit-mode-active a {
      cursor: text !important;
      pointer-events: none;
    }

    /* Loading Overlay */
    #loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(4px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      flex-direction: column;
      gap: 12px;
    }

    #loading-overlay.active {
      display: flex;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e2e8f0;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .loading-text {
      color: #64748b;
      font-size: 12px;
      font-weight: 500;
      font-family: sans-serif;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .error-box {
      padding: 1rem;
      background-color: #fee2e2;
      color: #b91c1c;
      border: 1px solid #f87171;
      border-radius: 0.5rem;
      margin: 1rem;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>

<body>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">AI is coding...</div>
  </div>

  <div id="root"></div>

  <script>
    const rootElement = document.getElementById("root");
    let reactRoot = null;
    let isEditMode = false;

    // ==========================================
    // 1. æ‹–æ‹½é€»è¾‘ (ä»…å…è®¸è°ƒæ•´å®½åº¦)
    // ==========================================
    const BORDER_SIZE = 12;
    let isResizing = false;
    // ä¸éœ€è¦ currentResizer å˜é‡äº†ï¼Œå› ä¸ºåªæœ‰ä¸€ç§æ¨¡å¼ï¼šå³ä¾§æ‹–æ‹½

    // è¾…åŠ©ï¼šåœæ­¢æ‹–æ‹½
    function stopDrag() {
      if (isResizing) {
        isResizing = false;
        rootElement.style.cursor = "default";
        document.body.style.cursor = "default";
      }
    }

    document.addEventListener("mousemove", (e) => {
      if (isResizing) {
        handleDrag(e);
      } else {
        if (!isEditMode) handleHover(e);
      }
    });

    document.addEventListener("mousedown", (e) => {
      // åªæœ‰å½“é¼ æ ‡æ ·å¼å˜ä¸º ew-resize æ—¶æ‰å…è®¸æ‹–æ‹½
      if (rootElement.style.cursor === "ew-resize" && !isEditMode) {
        isResizing = true;
        e.preventDefault();
        document.body.style.cursor = "ew-resize";
      }
    });

    // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå¤šé‡ä¿é™©é˜²æ­¢ç²˜æ»
    document.addEventListener("mouseup", stopDrag);
    document.addEventListener("mouseleave", stopDrag);
    window.addEventListener("blur", stopDrag);

    function handleHover(e) {
      const rect = rootElement.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;

      // ä»…æ£€æµ‹å³è¾¹ç¼˜
      const onRightEdge = x >= rect.right - BORDER_SIZE && x <= rect.right + BORDER_SIZE && y >= rect.top && y <= rect.bottom;

      if (onRightEdge) {
        rootElement.style.cursor = "ew-resize";
      } else {
        rootElement.style.cursor = "default";
      }
    }

    function handleDrag(e) {
      const rect = rootElement.getBoundingClientRect();
      // è®¡ç®—æ–°å®½åº¦ï¼šé¼ æ ‡å½“å‰X - å…ƒç´ å·¦ä¾§X
      const newWidth = e.clientX - rect.left;
      if (newWidth > 50) {
        rootElement.style.width = `${newWidth}px`;
      }
    }

    // ==========================================
    // 2. æ¶ˆæ¯é€šä¿¡ä¸æ¸²æŸ“é€»è¾‘
    // ==========================================
    window.addEventListener("message", (event) => {
      const { type, code, layout, key, value, color, enable } = event.data;

      if (type === "SHOW_LOADING") {
        document.getElementById("loading-overlay").classList.add("active");
        if (reactRoot) {
          reactRoot.unmount();
          reactRoot = null;
        }
        rootElement.innerHTML = "";
      }

      if (type === "RENDER") {
        document.getElementById("loading-overlay").classList.remove("active");
        applyLayout(layout);
        renderCode(code);
      }

      if (type === "UPDATE_STYLE") {
        if (key === "fontFamily") loadGoogleFont(value);
        document.getElementById("root").style.setProperty(key, value);
      }

      if (type === "UPDATE_CANVAS_BG") document.body.style.backgroundColor = color;
      if (type === "TOGGLE_EDIT_MODE") toggleEditMode(enable);
      if (type === "GET_SCREENSHOT") captureScreenshot();
    });

    function renderCode(rawCode) {
      try {
        let code = rawCode.replace(/import\s+.*?from\s+['"].*?['"];?/g, "").replace(/export\s+default\s+/g, "");
        if (code.trim().startsWith("<")) code = `const Component = () => (\n${code}\n);`;

        const codeToRun = `
<<<<<<< HEAD
=======
          const { useState, useEffect, useRef, useMemo, useCallback, useLayoutEffect, useReducer, useContext, createContext } = React;
          const { Check, X, ChevronDown, ChevronUp, ChevronLeft, ChevronRight, Menu, Search, User, ShoppingCart, Bell, Settings, ArrowRight, ArrowLeft, Plus, Minus, Trash, Edit, Save, Upload, Download, ExternalLink, Link, Copy, Share, Info, AlertCircle, AlertTriangle, CheckCircle, HelpCircle, Loader, RefreshCw, XCircle } = window.LucideIcons || {};
          
>>>>>>> e1d03a2496d321aa1730256bd0ab738d73787cf3
          ${code}
          let Target = null;
          try { if (typeof Component !== 'undefined') Target = Component; } catch(e){}
          try { if (typeof App !== 'undefined') Target = App; } catch(e){}
          Target;
        `;

        const compiled = Babel.transform(codeToRun, { presets: ["react"] }).code;
        const Component = eval(compiled);

        if (!reactRoot) reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(React.createElement(Component));
      } catch (err) {
        console.error(err);
        document.getElementById("loading-overlay").classList.remove("active");
        rootElement.innerHTML = `<div class="error-box">Render Error: ${err.message}</div>`;
      }
    }

    // å¸ƒå±€åº”ç”¨ï¼šåˆå§‹åŒ–æ—¶ä»…è®¾ç½®å®½åº¦
    function applyLayout(layout) {
      if (layout && layout.width && layout.width !== "auto") {
        rootElement.style.width = `${layout.width}px`;
      } else {
        rootElement.style.width = "auto";
      }
      // é«˜åº¦å§‹ç»ˆç”±å†…å®¹è‡ªåŠ¨æ’‘å¼€ï¼Œä¸å†è®¾ç½® minHeight
      rootElement.style.height = "auto";
    }

    function loadGoogleFont(fontName) {
      if (!fontName) return;
      const cleanName = fontName.split(',')[0].replace(/['"]/g, '').trim();
      if (["serif", "sans-serif", "monospace", "cursive"].includes(cleanName.toLowerCase())) return;
      const id = `font-${cleanName.replace(/\s+/g, '-')}`;
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id; link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${cleanName.replace(/\s+/g, '+')}:wght@400;500;700&display=swap`;
      document.head.appendChild(link);
    }

    // ğŸ”¥ æ ¸å¿ƒä¿®å¤ V60.25: æˆªå›¾é€»è¾‘
    async function captureScreenshot() {
      const root = document.getElementById("root");
      if (!root) return;

      const originalTransform = root.style.transform;
      root.style.transform = "none";
      const originalBorder = root.style.border;
      root.style.border = "none";

      const placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

      try {
        const dataUrl = await htmlToImage.toPng(root, {
          quality: 0.95,
          pixelRatio: 2,
          cacheBust: false,
          skipOnError: true,
          useCORS: true,
          imagePlaceholder: placeholder,
          filter: (node) => {
            return node.tagName !== 'LINK' && node.tagName !== 'SCRIPT';
          }
        });

        root.style.transform = originalTransform;
        root.style.border = originalBorder;

        window.parent.postMessage({ type: "SCREENSHOT_RESULT", dataUrl }, "*");

      } catch (error) {
        console.error("Capture failed:", error);
        root.style.transform = originalTransform;
        root.style.border = originalBorder;
        window.parent.postMessage({ type: "SCREENSHOT_RESULT", dataUrl: null }, "*");
      }
    }

    function toggleEditMode(enable) {
      isEditMode = enable;
      document.body.classList.toggle("edit-mode-active", enable);
      const root = document.getElementById("root");
      if (enable) wrapTextNodes(root);
      else unwrapTextNodes(root);
    }

    function wrapTextNodes(el) {
      Array.from(el.childNodes).forEach(node => {
        if (node.nodeType === 3 && node.nodeValue.trim().length > 0) {
          const span = document.createElement('span');
          span.contentEditable = "true"; span.className = "editable-text";
          span.onclick = e => { e.preventDefault(); e.stopPropagation(); };
          span.setAttribute("data-original-text", node.nodeValue);
          node.parentNode.insertBefore(span, node);
          span.appendChild(node);
        } else if (node.nodeType === 1 && !node.classList.contains('editable-text')) {
          wrapTextNodes(node);
        }
      });
    }

    function unwrapTextNodes(root) {
      root.querySelectorAll('.editable-text').forEach(span => {
        while (span.firstChild) span.parentNode.insertBefore(span.firstChild, span);
        span.parentNode.removeChild(span);
      });
      root.normalize();
    }

    document.addEventListener("focusout", (e) => {
      if (!isEditMode) return;
      if (e.target.classList.contains("editable-text")) {
        const oldText = e.target.getAttribute("data-original-text");
        const newText = e.target.innerText;
        if (oldText && newText !== oldText) {
          e.target.setAttribute("data-original-text", newText);
          window.top.postMessage({ type: "UPDATE_TEXT_CONTENT", oldText, newText }, "*");
        }
      }
    });
  </script>
</body>

</html>