<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Preview Sandbox</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: { extend: { colors: { clifford: "#da373d" } } },
    };
  </script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script src="html-to-image.js"></script>

  <style>
    body {
      margin: 0;
      /* ç»™ç»„ä»¶ç•™å‡ºå‘¼å¸ç©ºé—´ï¼Œé˜²æ­¢è´´è¾¹ */
      padding: 40px;
      min-height: 100vh;
      background-color: #f8fafc;
      /* é»˜è®¤èƒŒæ™¯ */
      display: flex;
      justify-content: center;
      align-items: flex-start;
      /* å…³é”®ï¼šé¡¶éƒ¨å¯¹é½ï¼Œé˜²æ­¢é«˜åº¦å˜åŒ–æ—¶ç»„ä»¶å‚ç›´è·³åŠ¨ */
      transition: background-color 0.2s ease;
      box-sizing: border-box;
    }

    #root {
      /* ğŸ”¥ æ ¸å¿ƒä¿®å¤ 1: åˆ‡æ¢ç›’å­æ¨¡å‹ä¸º content-box */
      /* è¿™æ · padding ä¸ä¼šå ç”¨ width çš„ç©ºé—´ï¼Œwidth ä¾ç„¶ç²¾å‡†æ§åˆ¶å†…å®¹åŒº */
      box-sizing: content-box;

      /* ğŸ”¥ æ ¸å¿ƒä¿®å¤ 2: å¢åŠ  24px å†…è¾¹è· (å‘¼å¸æ„Ÿ/é˜²è£å‰ª) */
      /* è¿™èƒ½ç¡®ä¿ç»„ä»¶çš„é˜´å½± (Shadow) å’Œ Hover æ”¾å¤§æ•ˆæœä¸è¢«åˆ‡æ‰ */
      padding: 24px;

      width: 100%;
      height: auto;

      display: block;
      transition: all 0.3s ease;
      transform-origin: top center;
      position: relative;
    }

    /* Error Display */
    .error-box {
      padding: 1rem;
      background-color: #fee2e2;
      color: #b91c1c;
      border: 1px solid #f87171;
      border-radius: 0.5rem;
      margin: 1rem;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
    }

    /* Edit Mode Indicators */
    .edit-mode-active .editable-text {
      outline: 2px dashed #3b82f6 !important;
      outline-offset: 2px;
      cursor: text !important;
      border-radius: 2px;
    }

    .edit-mode-active .editable-text:hover {
      background: rgba(59, 130, 246, 0.1);
    }

    .edit-mode-active a {
      cursor: text !important;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script>
    const rootElement = document.getElementById("root");
    let reactRoot = null;
    let isEditMode = false;

    // ==========================================
    // 1. Screenshot Logic
    // ==========================================
    function captureScreenshot() {
      const node = document.getElementById('root');

      if (typeof htmlToImage === 'undefined') {
        console.error("âŒ html-to-image.js æœªåŠ è½½ï¼");
        window.top.postMessage({ type: "SCREENSHOT_RESULT", dataUrl: null }, "*");
        return;
      }

      if (!node) {
        window.top.postMessage({ type: "SCREENSHOT_RESULT", dataUrl: null }, "*");
        return;
      }

      // æˆªå›¾å‰æš‚æ—¶å…³é—­ç¼–è¾‘æ¨¡å¼çš„é«˜äº®æ¡†
      const wasEditMode = isEditMode;
      if (wasEditMode) {
        document.body.classList.remove("edit-mode-active");
      }

      // è·å–å½“å‰ body èƒŒæ™¯è‰²ä½œä¸ºå›¾ç‰‡èƒŒæ™¯
      const currentBg = getComputedStyle(document.body).backgroundColor;

      htmlToImage.toPng(node, {
        quality: 0.95,
        backgroundColor: currentBg,
        style: { margin: 0 }, // ä¸éœ€è¦ marginï¼Œå› ä¸º #root å·²ç»æœ‰ padding
        skipOnError: true, // å¿½ç•¥è·¨åŸŸå›¾ç‰‡é”™è¯¯
        preferredFontFormat: 'woff2',
        fontEmbedCSS: '', // ç¦ç”¨å­—ä½“åµŒå…¥ä»¥é¿å…è·¨åŸŸæŠ¥é”™
        filter: (domNode) => {
          return !domNode.classList?.contains('ignore-screenshot');
        }
      })
        .then(function (dataUrl) {
          if (wasEditMode) document.body.classList.add("edit-mode-active");
          window.top.postMessage({ type: "SCREENSHOT_RESULT", dataUrl: dataUrl }, "*");
        })
        .catch(function (error) {
          console.error('Screenshot warning:', error);
          if (wasEditMode) document.body.classList.add("edit-mode-active");
          window.top.postMessage({ type: "SCREENSHOT_RESULT", dataUrl: null }, "*");
        });
    }

    // ==========================================
    // 2. Edit Mode (Text Editing)
    // ==========================================
    function toggleEditMode(enable) {
      isEditMode = enable;
      const root = document.getElementById("root");
      if (!root) return;

      if (enable) {
        document.body.classList.add("edit-mode-active");
        wrapTextNodes(root);
      } else {
        document.body.classList.remove("edit-mode-active");
        unwrapTextNodes(root);
      }
    }

    function wrapTextNodes(el) {
      const nodes = Array.from(el.childNodes);
      nodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim().length > 0) {
          const span = document.createElement('span');
          span.contentEditable = "true";
          span.className = "editable-text";
          span.onclick = (e) => { e.preventDefault(); e.stopPropagation(); };
          span.setAttribute("data-original-text", node.nodeValue);
          node.parentNode.insertBefore(span, node);
          span.appendChild(node);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          if (!node.classList.contains('editable-text') && node.tagName !== 'svg') {
            wrapTextNodes(node);
          }
        }
      });
    }

    function unwrapTextNodes(root) {
      const editables = root.querySelectorAll('.editable-text');
      editables.forEach(span => {
        while (span.firstChild) {
          span.parentNode.insertBefore(span.firstChild, span);
        }
        span.parentNode.removeChild(span);
      });
      root.normalize();
    }

    document.addEventListener("focusout", (e) => {
      if (!isEditMode) return;
      const target = e.target;
      if (target.classList.contains("editable-text")) {
        const oldText = target.getAttribute("data-original-text");
        const newText = target.innerText;
        if (oldText && newText !== oldText) {
          target.setAttribute("data-original-text", newText);
          window.top.postMessage({
            type: "UPDATE_TEXT_CONTENT",
            oldText: oldText,
            newText: newText
          }, "*");
        }
      }
    });

    // ==========================================
    // 3. Renderer & Layout
    // ==========================================
    function loadGoogleFont(fontName) {
      if (!fontName) return;
      const cleanName = fontName.split(',')[0].replace(/['"]/g, '').trim();
      if (["serif", "sans-serif", "monospace", "cursive"].includes(cleanName.toLowerCase())) return;
      const id = `font-${cleanName.replace(/\s+/g, '-')}`;
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${cleanName.replace(/\s+/g, '+')}:wght@400;500;700&display=swap`;
      document.head.appendChild(link);
    }

    // Polyfill for React variable if needed
    if (window.React) {
      Object.keys(window.React).forEach((key) => { window[key] = window.React[key]; });
    }

    // ğŸ”¥ Message Listener
    window.addEventListener("message", (event) => {
      const { type, code, layout, key, value, enable, color } = event.data;

      // 1. æ¸²æŸ“ä»£ç 
      if (type === "RENDER") {
        if (typeof Babel === "undefined") {
          setTimeout(() => window.postMessage(event.data, "*"), 100);
          return;
        }
        applyLayoutConstraints(layout);
        renderCode(code);
      }

      // 2. æ›´æ–°å¸ƒå±€
      if (type === "UPDATE_LAYOUT") applyLayoutConstraints(layout);

      // 3. æ›´æ–°æ ·å¼å˜é‡
      if (type === "UPDATE_STYLE") {
        const root = document.getElementById("root");
        if (root) {
          if (key === "fontFamily" || key === "font-family") loadGoogleFont(value);
          root.style.setProperty(key, value);
        }
      }

      // 4. ç¼–è¾‘æ¨¡å¼
      if (type === "TOGGLE_EDIT_MODE") toggleEditMode(enable);

      // 5. æ›´æ–°ç”»å¸ƒèƒŒæ™¯
      if (type === "UPDATE_CANVAS_BG") {
        document.body.style.backgroundColor = color;
      }

      // 6. æˆªå›¾æŒ‡ä»¤
      if (type === "GET_SCREENSHOT") captureScreenshot();
    });

    // ğŸ”¥ æ ¸å¿ƒé€»è¾‘ä¿®å¤ï¼šåº”ç”¨é«˜åº¦çº¦æŸ
    function applyLayoutConstraints(layout) {
      // A. å®½åº¦æ§åˆ¶
      // æ³¨æ„ï¼šç”±äº #root è®¾ç½®äº† box-sizing: content-boxï¼Œpadding ä¸ä¼šæŒ¤å è¿™é‡Œçš„ width
      if (layout && layout.width) {
        rootElement.style.width = `${layout.width}px`;
        rootElement.style.outline = "1px dashed #cbd5e1";
      } else {
        rootElement.style.width = "100%";
        rootElement.style.outline = "none";
      }

      // B. é«˜åº¦æ§åˆ¶ (Fix jumping border)
      // ä½¿ç”¨é‡‡é›†åˆ°çš„çœŸå®é«˜åº¦è®¾ç½® min-heightï¼Œç¡®ä¿è™šçº¿æ¡†ç´§è´´ç»„ä»¶
      if (layout && layout.height) {
        rootElement.style.minHeight = `${layout.height}px`;
      } else {
        rootElement.style.minHeight = "auto";
      }

      rootElement.style.boxShadow = "none";
    }

    function renderCode(rawCode) {
      try {
        let processedCode = rawCode
          .replace(/import\s+.*?from\s+['"].*?['"];?/g, "")
          .replace(/export\s+default\s+/g, "");

        // ç®€å•çš„ React ç»„ä»¶åŒ…è£…å™¨
        const codeToRun = `
            ${processedCode}
            let TargetComponent = null;
            if (typeof App !== 'undefined') TargetComponent = App;
            else if (typeof ProductFeatureCard !== 'undefined') TargetComponent = ProductFeatureCard;
            else if (typeof Component !== 'undefined') TargetComponent = Component;
            TargetComponent; 
          `;

        const compiledCode = Babel.transform(codeToRun, { presets: ["react"] }).code;
        const Component = eval(compiledCode);

        if (!Component) throw new Error("æ— æ³•æ‰¾åˆ°å¯æ¸²æŸ“çš„ç»„ä»¶ã€‚");
        if (!reactRoot) reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(React.createElement(Component));
      } catch (err) {
        console.error("Preview Render Error:", err);
        rootElement.innerHTML = `<div class="error-box"><strong>æ¸²æŸ“é”™è¯¯:</strong><br/>${err.message}</div>`;
      }
    }
  </script>
</body>

</html>